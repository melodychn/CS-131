<!DOCTYPE html>
<html lang='en'>
<head>
<title>Homework 1. Fixpoints and grammar filters</title>
<meta charset='UTF-8'>
<link rel='author' href='mailto:eggert@cs.ucla.edu'>
<link rel='license' href='copyright.html'>
</head>

<body>

<h1>Homework 1. Fixpoints and grammar filters</h1>

<p><small>[<a href='../index.html'>131 home</a> &gt; <a href='../homework.html'>Homework</a>]</small></p>

<h2>Introduction</h2>

<p>You are a reader for Computer Science 181, which asks students to
submit grammars that solve various problems. However, many of the
submitted grammars are trivially wrong, in several ways. Here is
one. Some grammars contain unreachable rules, that is,
rules that can never be reached from the start symbol by
applying zero or more rules. Unreachable rules
do not affect the language or parse trees generated by a
grammar, so in some sense they don't make the answers wrong, but
they're noise and they make grading harder. You'd like to filter out
the noise, and just grade the useful parts of each grammar.</p>

<p>You've heard that OCaml is a good language for writing compilers
and whatnot, so you decide to give it a try for this
application. While you're at it, you have a background
in <a href='https://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29'>fixed
point</a> and
<a href='https://en.wikipedia.org/wiki/Periodic_point'>periodic
point</a> theory, so you decide to give it a try too.</p>

<h2>Definitions</h2>

<dl>

<dt><dfn>fixed point</dfn><dt> <dd>(of a function <samp>f</samp>) A
point <samp>x</samp> such that <samp>f x = x</samp>. In this
description we are using OCaml notation, in which functions always
have one argument and parentheses are not needed around
arguments.</dd>

<dt><dfn>computed fixed point</dfn></dt> <dd>(of a
function <samp>f</samp> with respect to an initial
point <samp>x</samp>) A fixed point of <samp>f</samp> computed by
calculating <samp>x</samp>, <samp>f x</samp>, <samp>f (f
x)</samp>, <samp>f (f (f x))</samp>, etc., stopping when a fixed point
is found for <samp>f</samp>. If no fixed point is ever found by this
procedure, the computed fixed point is not defined for <samp>f</samp>
and <samp>x</samp>.</dd>

<dt><dfn>periodic point</dfn><dt> <dd> (of a function <samp>f</samp>
with period <samp>p</samp>) A point <samp>x</samp> such that <samp>f
(f ... (f x)) = x</samp>, where there are <samp>p</samp> occurrences
of <samp>f</samp> in the call.  That is, a periodic point is like a
fixed point, except the function returns to the point
after <samp>p</samp> iterations instead of 1 iteration. Every point is
a periodic point for <samp>p</samp>=0. A fixed point is a periodic
point for <samp>p</samp>=1.</dd>

<dt><dfn>computed periodic point</dfn></dt> <dd>(of a
function <samp>f</samp> with respect to a period <samp>p</samp> and an
initial point <samp>x</samp>) A periodic point of <samp>f</samp> with
period <samp>p</samp>, computed by calculating <samp>x</samp>, <samp>f
x</samp>, <samp>f (f x)</samp>, <samp>f (f (f x))</samp>, etc.,
stopping when a periodic point with period <samp>p</samp> is found
for <samp>f</samp>. The computed periodic point need not be equal
to <samp>x</samp>. If no periodic point is ever found by this
procedure, the computed periodic point is not defined
for <samp>f</samp>, <samp>p</samp>, and <samp>x</samp>.</dd>

<dt><dfn>symbol</dfn></dt> <dd>A symbol used in a grammar. It can be either a
nonterminal symbol or a terminal symbol; each kind of symbol has a
value, whose type is arbitrary. A symbol has the following OCaml type:

<pre><samp>type ('nonterminal, 'terminal) symbol =
  | N of 'nonterminal
  | T of 'terminal
</samp></pre>
</dd>

<dt><dfn>right hand side</dfn></dt> <dd>A list of symbols. It
corresponds to the right hand side of a single grammar rule. A right
hand side can be empty.</dd>

<dt><dfn>rule</dfn></dt> <dd>A pair, consisting of (1) a nonterminal value
(the left hand side of the grammar rule) and (2) a right hand side.</dd>

<dt><dfn>grammar</dfn></dt> <dd>A pair, consisting of a start symbol and a
list of rules. The start symbol is a nonterminal value.</dd>

</dl>

<h2>Assignment</h2>

<p>Let's warm up by modeling sets using OCaml lists. The empty list
represents the empty set, and if the list <samp>t</samp> represents
the set T, then the list <samp>h::t</samp> represents the set
{<samp>h</samp>}&cup;T. Although sets by definition do not contain
duplicates, the lists that represent sets can contain duplicates.
Another set of warmup exercises will compute fixed points.
Finally, you can write a function that filters unreachable rules.
</p>

<ol>
  <li>
Write a function <samp>subset a b</samp> that returns true iff
<em>a</em>&sube;<em>b</em>, i.e., if the
set represented by the list <samp>a</samp> is a subset of the set
represented by the list <samp>b</samp>. Every set is a subset of itself.
This function should be generic to lists of any type: that is, the type
of <samp>subset</samp> should be a generalization of <samp>'a list
-&gt; 'a list -&gt; bool</samp>.
</li>

<li>Write a function <samp>equal_sets a b</samp>
that returns true iff the represented sets are equal.
</li>

<li>Write a function <samp>set_union a b</samp> that returns
a list representing a&cup;b.
</li>

<li>Write a function <samp>set_intersection a b</samp> that returns a
list representing a&cap;b.
</li>

<li>Write a function <samp>set_diff a b</samp> that returns a list representing
<em>a</em>&minus;<em>b</em>, that is, the set of all members of
<em>a</em> that are not also members of <em>b</em>.</li>

<li>Write a
function <samp>computed_fixed_point eq f x</samp> that returns the
computed fixed point for <samp>f</samp> with respect
to <samp>x</samp>, assuming that <samp>eq</samp> is the equality
predicate for <samp>f</samp>'s domain. A common case is that
<samp>eq</samp> will be <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28=%29'><samp>(=)</samp></a>, that is, the builtin
equality predicate of OCaml; but any predicate can be used. If there
is no computed fixed point, your implementation can do whatever it
wants: for example, it can print a diagnostic, or go into a loop, or
send nasty email messages to the user's relatives.</li>

<li>OK, now for the real work. Write a function <samp>filter_reachable
g</samp> that returns a copy of the grammar <samp>g</samp> with all
unreachable rules removed. This
function should preserve the order of rules: that is, all rules that
are returned should be in the same order as the rules
in <samp>g</samp>.</li>

<li>Supply at least one test case for each of the above functions in
the style shown in the sample test cases below. When testing the
function <samp>F</samp> call the test
cases <samp>my_F_test0</samp>, <samp>my_F_test1</samp>, etc. For
example, for
<samp>subset</samp> your first test case should be
called <samp>my_subset_test0</samp>. Your test cases should exercise
all the above functions, even though the sample test cases do
not.</li>

</ol>

<p>Your code should follow these guidelines:</p>

<ol>
  <li>
Your code may use
the <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html'><samp>Pervasives</samp></a>
and <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html'><samp>List</samp></a>
modules, but it should use no other modules other than your own
code.</li>

<li>It is OK (and indeed encouraged) for your solutions to be based
on one another; for example, it is fine
for <samp>filter_reachable</samp> to use <samp>equal_sets</samp>
and <samp>computed_fixed_point</samp>.</li>

<li>Your code should prefer pattern matching to conditionals when
pattern matching is natural.</li>

<li>Your code should be free
of <a href='https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29'>side
effects</a> such as loops, assignment, input/output, <samp>incr</samp>,
and <samp>decr</samp>. Use recursion instead of loops.</li>

<li>Simplicity is more important than efficiency, but your code should
avoid using unnecessary time and space when it is easy to do so. For
example, instead of repeating a expression, compute its value once and
reuse the computed value.</li>

<li>The test cases below should work with your program. You are unlikely
to get credit for it otherwise.</li>

</ol>

<p>Assess your work by writing a brief after-action report that summarizes
why you solved the problem the way you did, other approaches
that you considered and rejected (and why you rejected them), and any
weaknesses in your solution in the context of its intended
application. This report should be a <a
href='http://en.wikipedia.org/wiki/Plain_text'>plain text</a> file
that is no more than 2000 bytes long.
See <a href='../comm.html'>Resources for oral presentations
and written reports</a> for advice on how to write assessments;
admittedly much of the advice there is overkill for the simple kind of
report we're looking for here.</p>

<h2>Submit</h2>

<p>Submit three files via CourseWeb. The file <samp>hw1.ml</samp>
should implement the abovementioned functions, along with any
auxiliary types and functions; in particular, it should define
the <samp>symbol</samp> type as shown above. The
file <samp>hw1test.ml</samp> should contain your test cases. The
file <samp>hw1.txt</samp> should hold your assessment. Please do not
put your name, student ID, or other personally identifying information
in your files.</p>

<h2>Sample test cases</h2>

<p>See <a href='hw1sample.ml'>hw1sample.ml</a> for a copy of these tests.</p>

<pre><samp>let subset_test0 = subset [] [1;2;3]
let subset_test1 = subset [3;1;3] [1;2;3]
let subset_test2 = <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALnot'>not</a> (subset [1;3;7] [4;1;3])

let equal_sets_test0 = equal_sets [1;3] [3;1;3]
let equal_sets_test1 = not (equal_sets [1;3;4] [3;1;3])

let set_union_test0 = equal_sets (set_union [] [1;2;3]) [1;2;3]
let set_union_test1 = equal_sets (set_union [3;1;3] [1;2;3]) [1;2;3]
let set_union_test2 = equal_sets (set_union [] []) []

let set_intersection_test0 =
  equal_sets (set_intersection [] [1;2;3]) []
let set_intersection_test1 =
  equal_sets (set_intersection [3;1;3] [1;2;3]) [1;3]
let set_intersection_test2 =
  equal_sets (set_intersection [1;2;3;4] [3;1;2;4]) [4;3;2;1]

let set_diff_test0 = equal_sets (set_diff [1;3] [1;4;3;1]) []
let set_diff_test1 = equal_sets (set_diff [4;3;1;1;3] [1;3]) [4]
let set_diff_test2 = equal_sets (set_diff [4;3;1] []) [1;3;4]
let set_diff_test3 = equal_sets (set_diff [] [4;3;1]) []

let computed_fixed_point_test0 =
  computed_fixed_point (=) (fun x -&gt; x <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28/%29'>/</a> 2) 1000000000 = 0
let computed_fixed_point_test1 =
  computed_fixed_point (=) (fun x -&gt; x <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28%20*.%20%29'>*.</a> 2.) 1. = <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinfinity'>infinity</a>
let computed_fixed_point_test2 =
  computed_fixed_point (=) <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALsqrt'>sqrt</a> 10. = 1.
let computed_fixed_point_test3 =
  ((computed_fixed_point (fun x y -&gt; <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALabs_float'>abs_float</a> (x <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28-.%29'>-.</a> y) &lt; 1.)
			 (fun x -&gt; x <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VAL%28/.%29'>/.</a> 2.)
			 10.)
   = 1.25)

(* An example grammar for a small subset of Awk.  *)

type awksub_nonterminals =
  | Expr | Lvalue | Incrop | Binop | Num

let awksub_rules =
   [Expr, [T"("; N Expr; T")"];
    Expr, [N Num];
    Expr, [N Expr; N Binop; N Expr];
    Expr, [N Lvalue];
    Expr, [N Incrop; N Lvalue];
    Expr, [N Lvalue; N Incrop];
    Lvalue, [T"$"; N Expr];
    Incrop, [T"++"];
    Incrop, [T"--"];
    Binop, [T"+"];
    Binop, [T"-"];
    Num, [T"0"];
    Num, [T"1"];
    Num, [T"2"];
    Num, [T"3"];
    Num, [T"4"];
    Num, [T"5"];
    Num, [T"6"];
    Num, [T"7"];
    Num, [T"8"];
    Num, [T"9"]]

let awksub_grammar = Expr, awksub_rules

let awksub_test0 =
  filter_reachable awksub_grammar = awksub_grammar

let awksub_test1 =
  filter_reachable (Expr, <a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html#VALtl'>List.tl</a> awksub_rules) = (Expr, List.tl awksub_rules)

let awksub_test2 =
  filter_reachable (Lvalue, awksub_rules) = (Lvalue, awksub_rules)

let awksub_test3 =
  filter_reachable (Expr, List.tl (List.tl awksub_rules)) =
    (Expr,
     [Expr, [N Expr; N Binop; N Expr];
      Expr, [N Lvalue];
      Expr, [N Incrop; N Lvalue];
      Expr, [N Lvalue; N Incrop];
      Lvalue, [T "$"; N Expr];
      Incrop, [T "++"];
      Incrop, [T "--"];
      Binop, [T "+"];
      Binop, [T "-"]])

let awksub_test4 =
  filter_reachable (Expr, List.tl (List.tl (List.tl awksub_rules))) =
    (Expr,
     [Expr, [N Lvalue];
      Expr, [N Incrop; N Lvalue];
      Expr, [N Lvalue; N Incrop];
      Lvalue, [T "$"; N Expr];
      Incrop, [T "++"];
      Incrop, [T "--"]])

type giant_nonterminals =
  | Conversation | Sentence | Grunt | Snore | Shout | Quiet

let giant_grammar =
  Conversation,
  [Snore, [T"ZZZ"];
   Quiet, [];
   Grunt, [T"khrgh"];
   Shout, [T"aooogah!"];
   Sentence, [N Quiet];
   Sentence, [N Grunt];
   Sentence, [N Shout];
   Conversation, [N Snore];
   Conversation, [N Sentence; T","; N Conversation]]

let giant_test0 =
  filter_reachable giant_grammar = giant_grammar

let giant_test1 =
  filter_reachable (Sentence, List.tl (<a href='https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALsnd'>snd</a> giant_grammar)) =
    (Sentence,
     [Quiet, []; Grunt, [T "khrgh"]; Shout, [T "aooogah!"];
      Sentence, [N Quiet]; Sentence, [N Grunt]; Sentence, [N Shout]])

let giant_test2 =
  filter_reachable (Quiet, snd giant_grammar) = (Quiet, [Quiet, []])
</samp></pre>

<h2>Sample use of test cases</h2>

<p>When testing on SEASnet, use one of the machines
<samp>lnxsrv06.seas.ucla.edu</samp>,
<samp>lnxsrv07.seas.ucla.edu</samp>,
<samp>lnxsrv09.seas.ucla.edu</samp>, and
<samp>lnxsrv10.seas.ucla.edu</samp>. Make
sure <samp>/usr/local/cs/bin</samp> is at the start of your path, so
that you get the proper version of OCaml.  To do this, append the
following lines to your <samp>$HOME/.profile</samp> file if you
use <a href='https://www.gnu.org/software/bash/'><samp>bash</samp></a>
or <a href='http://www.kornshell.com/'><samp>ksh</samp></a>:</p>

<pre><samp>export PATH=/usr/local/cs/bin:$PATH
</samp></pre>

<p>or the following line to your <samp>$HOME/.login</samp> file if you use
<a href='https://en.wikipedia.org/wiki/Tcsh'><samp>tcsh</samp></a> or
<a href='https://en.wikipedia.org/wiki/C_shell'>csh</a>:</p>

<pre><samp>set path=(/usr/local/cs/bin $path)
</samp></pre>

<p>The command <samp>ocaml</samp> should output the version number 4.10.0.</p>

<p>If you put the <a href='hw1sample.ml'>sample test cases</a> into a file
<samp>hw1sample.ml</samp>, you should be able to use it as follows to
test your <samp>hw1.ml</samp> solution on the SEASnet implementation
of OCaml. Similarly, the command <samp>#use "hw1test.ml";;</samp>
should run your own test cases on your solution.</p>

<pre><samp>$ ocaml
        OCaml version 4.10.0

# #use "hw1.ml";;
type ('a, 'b) symbol = N of 'a | T of 'b
...
# #use "<a href='hw1sample.ml'>hw1sample.ml</a>";;
val subset_test0 : bool = true
val subset_test1 : bool = true
val subset_test2 : bool = true
val equal_sets_test0 : bool = true
val equal_sets_test1 : bool = true
val set_union_test0 : bool = true
val set_union_test1 : bool = true
val set_union_test2 : bool = true
val set_intersection_test0 : bool = true
val set_intersection_test1 : bool = true
val set_intersection_test2 : bool = true
val computed_fixed_point_test0 : bool = true
val computed_fixed_point_test1 : bool = true
val computed_fixed_point_test2 : bool = true
val computed_fixed_point_test3 : bool = true
type awksub_nonterminals = Expr | Lvalue | Incrop | Binop | Num
val awksub_rules :
  (awksub_nonterminals * (awksub_nonterminals, string) symbol list) list =
  [(Expr, [T "("; N Expr; T ")"]); (Expr, [N Num]);
   (Expr, [N Expr; N Binop; N Expr]); (Expr, [N Lvalue]);
   (Expr, [N Incrop; N Lvalue]); (Expr, [N Lvalue; N Incrop]);
   (Lvalue, [T "$"; N Expr]); (Incrop, [T "++"]); (Incrop, [T "--"]);
   (Binop, [T "+"]); (Binop, [T "-"]); (Num, [T "0"]); (Num, [T "1"]);
   (Num, [T "2"]); (Num, [T "3"]); (Num, [T "4"]); (Num, [T "5"]);
   (Num, [T "6"]); (Num, [T "7"]); (Num, [T "8"]); (Num, [T "9"])]
val awksub_grammar :
  awksub_nonterminals *
  (awksub_nonterminals * (awksub_nonterminals, string) symbol list) list =
  (Expr,
   [(Expr, [T "("; N Expr; T ")"]); (Expr, [N Num]);
    (Expr, [N Expr; N Binop; N Expr]); (Expr, [N Lvalue]);
    (Expr, [N Incrop; N Lvalue]); (Expr, [N Lvalue; N Incrop]);
    (Lvalue, [T "$"; N Expr]); (Incrop, [T "++"]); (Incrop, [T "--"]);
    (Binop, [T "+"]); (Binop, [T "-"]); (Num, [T "0"]); (Num, [T "1"]);
    (Num, [T "2"]); (Num, [T "3"]); (Num, [T "4"]); (Num, [T "5"]);
    (Num, [T "6"]); (Num, [T "7"]); (Num, [T "8"]); (Num, [T "9"])])
val awksub_test0 : bool = true
val awksub_test1 : bool = true
val awksub_test2 : bool = true
val awksub_test3 : bool = true
val awksub_test4 : bool = true
type giant_nonterminals =
    Conversation
  | Sentence
  | Grunt
  | Snore
  | Shout
  | Quiet
val giant_grammar :
  giant_nonterminals *
  (giant_nonterminals * (giant_nonterminals, string) symbol list) list =
  (Conversation,
   [(Snore, [T "ZZZ"]); (Quiet, []); (Grunt, [T "khrgh"]);
    (Shout, [T "aooogah!"]); (Sentence, [N Quiet]); (Sentence, [N Grunt]);
    (Sentence, [N Shout]); (Conversation, [N Snore]);
    (Conversation, [N Sentence; T ","; N Conversation])])
val giant_test0 : bool = true
val giant_test1 : bool = true
val giant_test2 : bool = true
#
</samp></pre>

<footer>
<hr>
<small>
 &copy; 2006&ndash;2011, 2013&ndash;2020
 <a href='../mail-eggert.html'>Paul Eggert</a>.
 See <a href='../copyright.html'>copying rules</a>.<br>

 $Id: hw1.html,v 1.80 2020/03/29 21:50:09 eggert Exp $

</small>
</footer>

</body>
</html>
